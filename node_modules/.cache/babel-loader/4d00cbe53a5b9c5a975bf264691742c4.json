{"ast":null,"code":"import get from 'lodash.get';\nimport isNil from 'lodash.isnil';\nimport mergeWith from 'lodash.mergewith';\nimport cloneDeep from 'lodash.clonedeep';\nimport { themePropertyMap } from './../../theme/base';\nimport { getClosestBreakpoint, findLastValidBreakpoint, hasValidBreakpointFormat, extractInObject } from './../../theme/tools';\nimport { useContrastText } from '../useContrastText';\n/*\n Extract props from theme props and omit those from props\n*/\n\n/**\n *\n * @param props Props passed by the user\n * @param theme Theme object\n * @param colorModeProps `colorMode` object\n * @param componentTheme Theme for specific components\n * @param currentBreakpoint Current breakpoint values\n * @returns Extracting props from defaultProps while overriding the props that are already present\n */\n\nexport function extractProps(props, theme, _ref, componentTheme, currentBreakpoint) {\n  let {} = _ref;\n  let newProps = {};\n\n  for (let property in props) {\n    // If the property exists in themePropertyMap then get its value\n    if (themePropertyMap[property]) {\n      let propValues = extractPropertyFromFunction(property, props, theme, componentTheme);\n\n      if (typeof propValues === 'string' || typeof propValues === 'number') {\n        newProps[property] = propValues;\n      } else if (!isNil(propValues)) {\n        for (let nestedProp in propValues) {\n          newProps[nestedProp] = get(theme, \"\".concat(themePropertyMap[nestedProp], \".\").concat(propValues[nestedProp]), propValues[nestedProp]);\n        }\n      } else if (property === 'shadow') {\n        let shadowProps = theme[themePropertyMap[property]][props[property]];\n\n        if (!isNil(shadowProps)) {\n          newProps = { ...newProps,\n            ...shadowProps\n          };\n        }\n      } else {\n        newProps[property] = resolveValueWithBreakpoint(props[property], theme.breakpoints, currentBreakpoint, property);\n      }\n    } else {\n      newProps[property] = resolveValueWithBreakpoint(props[property], theme.breakpoints, currentBreakpoint, property);\n    }\n  }\n\n  return cloneDeep(newProps);\n}\n/*\nRemove props from defaultProps that are already present in props\n*/\n\nfunction filterDefaultProps(props, defaultProps) {\n  let [, resultProps] = extractInObject(defaultProps, Object.keys(props));\n  return resultProps;\n}\n/**\n * If property is functional in componentTheme, get its returned object\n *\n * @param property : name of the prop\n * @param props : all props\n * @param theme : provided theme without components\n * @param componentTheme : component specific theme\n * @returns\n */\n\n\nexport const extractPropertyFromFunction = (property, props, theme, componentTheme) => {\n  let propValues; // Check if the entry in the theme is a function then calling it with all theme and props as params\n\n  if (componentTheme && typeof componentTheme[themePropertyMap[property]] === 'function') {\n    let funcProps = componentTheme[themePropertyMap[property]]({\n      theme,\n      ...props\n    }); // Check if returned object from componentTheme is a nested object\n\n    let isNested = Object.keys(funcProps).some(function (key) {\n      return funcProps[key] && typeof funcProps[key] === 'object';\n    }); // If the returned value is nested object then find the property value in it, otherwise return the whole object\n\n    propValues = isNested ? { ...get(funcProps, \"\".concat(props[property]))\n    } : { ...funcProps\n    };\n  } else {\n    // If the entry is any value other than function then return the whole object or value\n    propValues = get(componentTheme, \"\".concat(themePropertyMap[property], \".\").concat(props[property]));\n  }\n\n  return propValues;\n};\n/*\nMerge _props and apply contrastText color if not passed by theme or user\n*/\n\nexport function mergeUnderscoreProps(newProps, props) {\n  const _props = Object.keys(newProps).filter(propName => propName.startsWith('_'));\n\n  _props.forEach(propName => {\n    var _newProps$bg, _newProps$propName$co, _newProps$propName, _props$propName; // Adding color based on bg contrast if no color is given\n\n\n    const bg = (_newProps$bg = newProps.bg) !== null && _newProps$bg !== void 0 ? _newProps$bg : newProps.backgroundColor;\n    const textColor = bg ? {\n      color: useContrastText(bg, (_newProps$propName$co = (_newProps$propName = newProps[propName]) === null || _newProps$propName === void 0 ? void 0 : _newProps$propName.color) !== null && _newProps$propName$co !== void 0 ? _newProps$propName$co : (_props$propName = props[propName]) === null || _props$propName === void 0 ? void 0 : _props$propName.color)\n    } : {}; // Overriding calculated props with user added props\n\n    newProps[propName] = { ...textColor,\n      ...newProps[propName],\n      ...props[propName]\n    };\n  });\n\n  return newProps;\n}\n/**\n *\n * Checks the property and resolves it if it has breakpoints\n * @param values : value from props\n * @param currentBreakpoint : current value for which breakpoint will be calculated\n * @param property : property name\n * @returns\n */\n\nexport const resolveValueWithBreakpoint = (values, breakpointTheme, currentBreakpoint, property) => {\n  if (hasValidBreakpointFormat(values, breakpointTheme, property)) {\n    // Check the last valid breakpoint value from all values\n    // If current breakpoint is `md` and we have `base` then `lg`, then last value will be taken(`base` in this case)\n    return findLastValidBreakpoint(values, breakpointTheme, currentBreakpoint);\n  } else {\n    return values;\n  }\n};\n/**\n * Takes all prop related data and returns the props that needs to be applied to the component\n *\n * @param theme Theme object\n * @param colorModeProps Color mode information\n * @param componentTheme Theme object for the specific component\n * @param props Props passed by the user\n * @param windowWidth Width of the current window\n * @returns props to be applied\n */\n\nexport function calculateProps(theme, colorModeProps, componentTheme, props, windowWidth) {\n  let currentBreakpoint = getClosestBreakpoint(theme.breakpoints, windowWidth);\n\n  if (!props) {\n    props = {};\n  }\n\n  let newProps;\n\n  if (componentTheme) {\n    // Extracting props from defaultProps\n    newProps = extractProps(filterDefaultProps(props, componentTheme.defaultProps), theme, colorModeProps, componentTheme, currentBreakpoint); // Extracting props from base style\n\n    let componentBaseStyle = typeof componentTheme.baseStyle !== 'function' ? componentTheme.baseStyle : componentTheme.baseStyle({\n      theme,\n      ...newProps,\n      ...props,\n      ...colorModeProps\n    });\n    newProps = mergeWith(newProps, componentBaseStyle, // @ts-ignore\n    (objValue, srcValue, key) => {\n      if (!isNil(objValue)) {\n        delete newProps[key];\n      }\n    });\n    const variant = props.variant || get(componentTheme, 'defaultProps.variant'); // Extracting props from variant\n\n    if (variant && componentTheme.variants && componentTheme.variants[variant]) {\n      const colorScheme = props.colorScheme || get(componentTheme, 'defaultProps.colorScheme');\n      let variantProps = componentTheme.variants[variant]({ ...props,\n        ...newProps,\n        colorScheme,\n        theme,\n        ...colorModeProps\n      });\n      variantProps = extractProps(variantProps, theme, colorModeProps, componentTheme, currentBreakpoint); // added this to handle order of props\n\n      newProps = mergeWith(newProps, variantProps, // @ts-ignore\n      (objValue, srcValue, key) => {\n        if (!isNil(objValue)) {\n          delete newProps[key];\n        }\n      });\n      delete newProps.variant;\n      delete newProps.colorScheme;\n    }\n  } // Extracting props from normal props\n\n\n  let extractedProps = extractProps(props, theme, colorModeProps, componentTheme, currentBreakpoint); // added this to handle order of props\n  // @ts-ignore\n\n  newProps = mergeWith(newProps, extractedProps, (objValue, srcValue, key) => {\n    if (!isNil(objValue)) {\n      delete newProps[key];\n    }\n  });\n  newProps = mergeUnderscoreProps(newProps, props);\n  return newProps;\n}","map":{"version":3,"mappings":"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","names":["get","isNil","mergeWith","cloneDeep","themePropertyMap","getClosestBreakpoint","findLastValidBreakpoint","hasValidBreakpointFormat","extractInObject","useContrastText","extractProps","props","theme","componentTheme","currentBreakpoint","newProps","property","propValues","extractPropertyFromFunction","nestedProp","shadowProps","resolveValueWithBreakpoint","breakpoints","filterDefaultProps","defaultProps","resultProps","Object","keys","funcProps","isNested","some","key","mergeUnderscoreProps","_props","filter","propName","startsWith","forEach","bg","backgroundColor","textColor","color","_newProps$propName","_props$propName","values","breakpointTheme","calculateProps","colorModeProps","windowWidth","componentBaseStyle","baseStyle","objValue","srcValue","variant","variants","colorScheme","variantProps","extractedProps"],"sources":["/home/ttpl-rt-68/Documents/ULP/ulp-card/node_modules/native-base/lib/module/hooks/useThemeProps/utils.ts"],"sourcesContent":["import get from 'lodash.get';\nimport isNil from 'lodash.isnil';\nimport mergeWith from 'lodash.mergewith';\nimport cloneDeep from 'lodash.clonedeep';\nimport { themePropertyMap } from './../../theme/base';\nimport {\n  getClosestBreakpoint,\n  findLastValidBreakpoint,\n  hasValidBreakpointFormat,\n  extractInObject,\n} from './../../theme/tools';\nimport { useContrastText } from '../useContrastText';\n\n/*\n Extract props from theme props and omit those from props\n*/\n/**\n *\n * @param props Props passed by the user\n * @param theme Theme object\n * @param colorModeProps `colorMode` object\n * @param componentTheme Theme for specific components\n * @param currentBreakpoint Current breakpoint values\n * @returns Extracting props from defaultProps while overriding the props that are already present\n */\nexport function extractProps(\n  props: any,\n  theme: any,\n  {},\n  componentTheme: any,\n  currentBreakpoint: number\n) {\n  let newProps: any = {};\n  for (let property in props) {\n    // If the property exists in themePropertyMap then get its value\n    if (themePropertyMap[property]) {\n      let propValues = extractPropertyFromFunction(\n        property,\n        props,\n        theme,\n        componentTheme\n      );\n      if (typeof propValues === 'string' || typeof propValues === 'number') {\n        newProps[property] = propValues;\n      } else if (!isNil(propValues)) {\n        for (let nestedProp in propValues) {\n          newProps[nestedProp] = get(\n            theme,\n            `${themePropertyMap[nestedProp]}.${propValues[nestedProp]}`,\n            propValues[nestedProp]\n          );\n        }\n      } else if (property === 'shadow') {\n        let shadowProps = theme[themePropertyMap[property]][props[property]];\n        if (!isNil(shadowProps)) {\n          newProps = { ...newProps, ...shadowProps };\n        }\n      } else {\n        newProps[property] = resolveValueWithBreakpoint(\n          props[property],\n          theme.breakpoints,\n          currentBreakpoint,\n          property\n        );\n      }\n    } else {\n      newProps[property] = resolveValueWithBreakpoint(\n        props[property],\n        theme.breakpoints,\n        currentBreakpoint,\n        property\n      );\n    }\n  }\n  return cloneDeep(newProps);\n}\n\n/*\nRemove props from defaultProps that are already present in props\n*/\nfunction filterDefaultProps(props: any, defaultProps: any) {\n  let [, resultProps] = extractInObject(defaultProps, Object.keys(props));\n  return resultProps;\n}\n\n/**\n * If property is functional in componentTheme, get its returned object\n *\n * @param property : name of the prop\n * @param props : all props\n * @param theme : provided theme without components\n * @param componentTheme : component specific theme\n * @returns\n */\nexport const extractPropertyFromFunction = (\n  property: string,\n  props: any,\n  theme: any,\n  componentTheme: any\n) => {\n  let propValues;\n  // Check if the entry in the theme is a function then calling it with all theme and props as params\n  if (\n    componentTheme &&\n    typeof componentTheme[themePropertyMap[property]] === 'function'\n  ) {\n    let funcProps = componentTheme[themePropertyMap[property]]({\n      theme,\n      ...props,\n    });\n    // Check if returned object from componentTheme is a nested object\n    let isNested: boolean = Object.keys(funcProps).some(function (key) {\n      return funcProps[key] && typeof funcProps[key] === 'object';\n    });\n    // If the returned value is nested object then find the property value in it, otherwise return the whole object\n    propValues = isNested\n      ? { ...get(funcProps, `${props[property]}`) }\n      : { ...funcProps };\n  } else {\n    // If the entry is any value other than function then return the whole object or value\n    propValues = get(\n      componentTheme,\n      `${themePropertyMap[property]}.${props[property]}`\n    );\n  }\n  return propValues;\n};\n\n/*\nMerge _props and apply contrastText color if not passed by theme or user\n*/\nexport function mergeUnderscoreProps(newProps: any, props: any) {\n  const _props = Object.keys(newProps).filter((propName) =>\n    propName.startsWith('_')\n  );\n  _props.forEach((propName: string) => {\n    // Adding color based on bg contrast if no color is given\n    const bg = newProps.bg ?? newProps.backgroundColor;\n    const textColor = bg\n      ? {\n          color: useContrastText(\n            bg,\n            newProps[propName]?.color ?? props[propName]?.color\n          ),\n        }\n      : {};\n    // Overriding calculated props with user added props\n    newProps[propName] = {\n      ...textColor,\n      ...newProps[propName],\n      ...props[propName],\n    };\n  });\n  return newProps;\n}\n\n/**\n *\n * Checks the property and resolves it if it has breakpoints\n * @param values : value from props\n * @param currentBreakpoint : current value for which breakpoint will be calculated\n * @param property : property name\n * @returns\n */\nexport const resolveValueWithBreakpoint = (\n  values: any,\n  breakpointTheme: any,\n  currentBreakpoint: number,\n  property: any\n) => {\n  if (hasValidBreakpointFormat(values, breakpointTheme, property)) {\n    // Check the last valid breakpoint value from all values\n    // If current breakpoint is `md` and we have `base` then `lg`, then last value will be taken(`base` in this case)\n    return findLastValidBreakpoint(values, breakpointTheme, currentBreakpoint);\n  } else {\n    return values;\n  }\n};\n\n/**\n * Takes all prop related data and returns the props that needs to be applied to the component\n *\n * @param theme Theme object\n * @param colorModeProps Color mode information\n * @param componentTheme Theme object for the specific component\n * @param props Props passed by the user\n * @param windowWidth Width of the current window\n * @returns props to be applied\n */\nexport function calculateProps(\n  theme: any,\n  colorModeProps: any,\n  componentTheme: any,\n  props: any,\n  windowWidth: any\n) {\n  let currentBreakpoint = getClosestBreakpoint(theme.breakpoints, windowWidth);\n  if (!props) {\n    props = {};\n  }\n\n  let newProps: any;\n  if (componentTheme) {\n    // Extracting props from defaultProps\n    newProps = extractProps(\n      filterDefaultProps(props, componentTheme.defaultProps),\n      theme,\n      colorModeProps,\n      componentTheme,\n      currentBreakpoint\n    );\n    // Extracting props from base style\n    let componentBaseStyle =\n      typeof componentTheme.baseStyle !== 'function'\n        ? componentTheme.baseStyle\n        : componentTheme.baseStyle({\n            theme,\n            ...newProps,\n            ...props,\n            ...colorModeProps,\n          });\n    newProps = mergeWith(\n      newProps,\n      componentBaseStyle,\n      // @ts-ignore\n      (objValue, srcValue, key) => {\n        if (!isNil(objValue)) {\n          delete newProps[key];\n        }\n      }\n    );\n\n    const variant =\n      props.variant || get(componentTheme, 'defaultProps.variant');\n    // Extracting props from variant\n    if (\n      variant &&\n      componentTheme.variants &&\n      componentTheme.variants[variant]\n    ) {\n      const colorScheme =\n        props.colorScheme || get(componentTheme, 'defaultProps.colorScheme');\n      let variantProps = componentTheme.variants[variant]({\n        ...props,\n        ...newProps,\n        colorScheme,\n        theme,\n        ...colorModeProps,\n      });\n      variantProps = extractProps(\n        variantProps,\n        theme,\n        colorModeProps,\n        componentTheme,\n        currentBreakpoint\n      );\n      // added this to handle order of props\n      newProps = mergeWith(\n        newProps,\n        variantProps,\n        // @ts-ignore\n        (objValue, srcValue, key) => {\n          if (!isNil(objValue)) {\n            delete newProps[key];\n          }\n        }\n      );\n      delete newProps.variant;\n      delete newProps.colorScheme;\n    }\n  }\n  // Extracting props from normal props\n  let extractedProps = extractProps(\n    props,\n    theme,\n    colorModeProps,\n    componentTheme,\n    currentBreakpoint\n  );\n  // added this to handle order of props\n  // @ts-ignore\n  newProps = mergeWith(newProps, extractedProps, (objValue, srcValue, key) => {\n    if (!isNil(objValue)) {\n      delete newProps[key];\n    }\n  });\n  newProps = mergeUnderscoreProps(newProps, props);\n  return newProps;\n}\n"]},"metadata":{},"sourceType":"module"}